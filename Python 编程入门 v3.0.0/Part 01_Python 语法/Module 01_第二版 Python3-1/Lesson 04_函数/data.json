{
  "data": {
    "lesson": {
      "id": 534167,
      "key": "d91fa76c-cfb4-40b5-8aec-40d5b25a1e58",
      "title": "函数",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "zh-cn",
      "summary": "你将学习如何定义函数。还将学习如何将程序拆分为多个部分，使得代码的结构更加合理。这部分不是必学，但学习后能更好地掌握和理解实战项目。",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://s3.amazonaws.com/zips.udacity-data.com/d91fa76c-cfb4-40b5-8aec-40d5b25a1e58/534167/1544952644848/%E5%87%BD%E6%95%B0+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://s3.amazonaws.com/zips.udacity-data.com/d91fa76c-cfb4-40b5-8aec-40d5b25a1e58/534167/1544952641647/%E5%87%BD%E6%95%B0+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 534059,
          "key": "e758630d-d2f2-4a80-a2ba-eb9f852ac1e5",
          "title": "简介",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e758630d-d2f2-4a80-a2ba-eb9f852ac1e5",
            "completed_at": "2018-06-12T07:42:21.429Z",
            "last_viewed_at": "2019-02-23T09:10:46.201Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 533992,
              "key": "176dfcbc-1290-4519-a707-008a443833fb",
              "title": "L4 01 简介 V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "p5L4rTV1Pgk",
                "china_cdn_id": "p5L4rTV1Pgk.mp4"
              }
            },
            {
              "id": 533993,
              "key": "995586a2-6592-4605-bbf4-22b878166fe4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 函数\n欢迎学习这节关于函数的课程！你将学习：\n- 函数定义\n- 变量作用域\n- 文档\n- Lambda 表达式\n- 迭代器和生成器",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534074,
          "key": "97c1d194-e640-4dda-b7c8-770db5a4cb0f",
          "title": "定义函数",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "97c1d194-e640-4dda-b7c8-770db5a4cb0f",
            "completed_at": "2018-06-12T07:43:31.593Z",
            "last_viewed_at": "2019-05-12T14:16:19.171Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 569353,
              "key": "5e33764e-5058-477b-a9b9-26d637f87982",
              "title": "Definindo funções",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "IP_tJYhynbc",
                "china_cdn_id": "IP_tJYhynbc.mp4"
              }
            },
            {
              "id": 534000,
              "key": "4c58bf02-08ba-4516-a9a9-8085b3b025a7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 定义函数\n函数定义示例：\n```python\ndef cylinder_volume(height, radius):\n    pi = 3.14159\n    return height * pi * radius ** 2\n```\n定义 cylinder_volume 函数后，我们可以如下所示地**调用**该函数。 \n```python\ncylinder_volume(10, 3)\n```\n函数定义包含几个重要部分。\n\n### 函数头部\n我们从函数头部开始，即函数定义的第一行。\n1. 函数头部始终以关键字 `def` 开始，表示这是函数定义。\n2. 然后是函数名称（在此例中是 `cylinder_volume`，因为函数名是要一个单词，所以需要用_进行连接），遵循的是和变量一样的命名规范。你可以在本页面下方回顾下命名规范。\n3. 名称之后是括号，其中可能包括用英文逗号分隔的参数（在此例中是 `height` 和 `radius`）。[形参（或实参）](https://stackoverflow.com/questions/3176310/difference-between-parameter-and-argument)是当函数被调用时作为输入传入的值，用在函数主体中。如果函数没有参数，这些括号留空。\n4. 头部始终以英文冒号 `:` 结束。\n\n### 函数主体\n函数的剩余部分包含在主题中，也就是函数完成操作的部分。\n1. 函数主体是在头部行之后缩进的代码。在此例中是定义 π 和返回体积的两行代码。\n2. 在此主体中，我们可以引用参数并定义新的变量，这些变量只能在这些缩进代码行内使用。\n3. 主体将经常包括 `return` 语句，用于当函数被调用时返回输出值。`return` 语句包括关键字 `return`，然后是经过评估以获得函数输出值的表达式。如果没有 `return` 语句，函数直接返回 None（例如内置 `print()` 函数）。\n\n### 函数的命名规范\n函数名称遵守和变量一样的命名规范。\n\n1. 仅在函数名称中使用普通字母、数字和下划线。不能有空格，需要以字母或下划线开头。\n2. **不能使用在 Python 中具有重要作用的保留字或内置标识符**，我们将在这门课程中学习这方面的知识。要了解 python 保留字列表，请参阅[此处](https://pentangle.net/python/handbook/node52.html)。 \n3. 尝试使用可以帮助读者了解函数作用的描述性名称。",
              "instructor_notes": ""
            },
            {
              "id": 569356,
              "key": "64f85f1b-6772-46f1-b561-c0c398fa31ca",
              "title": "Argumentos padrão",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "cG6UfBZX2KI",
                "china_cdn_id": "cG6UfBZX2KI.mp4"
              }
            },
            {
              "id": 534002,
              "key": "0d2880ff-e5d9-4d48-89e5-ef1b735acde4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 默认参数\n我们可以向函数中添加默认参数，以便为在函数调用中未指定的参数提供默认值。\n```python\ndef cylinder_volume(height, radius=5):\n    pi = 3.14159\n    return height * pi * radius ** 2\n```\n在上述示例中，如果在函数调用中忽略了 `radius`，则将该参数设为 5。如果我们调用 `cylinder_volume(10)`，该函数将使用 10 作为高度，使用 5 作为半径。但是，如果调用 `cylinder_volume(10, 7)`，7 将覆盖默认的值 5。\n\n此外注意，我们按照位置向参数传递值。可以通过两种方式传递值：按照位置和按照名称。下面两个函数的效果是一样的。 \n```python\ncylinder_volume(10, 7)  # pass in arguments by position\ncylinder_volume(height=10, radius=7)  # pass in arguments by name\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534065,
          "key": "3487f6f7-ff59-40cf-8746-106c6bdca7a5",
          "title": "练习：定义函数",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3487f6f7-ff59-40cf-8746-106c6bdca7a5",
            "completed_at": "2018-06-12T08:11:07.120Z",
            "last_viewed_at": "2019-02-23T09:25:14.881Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 533994,
              "key": "961e93d7-f8cb-42ec-8d44-b4426ede550e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 练习：人口密度函数\n\n写一个名称为 `population_density` 的函数，该函数有两个参数 `population` 和 `land_area`，并根据这两个值返回人口密度。我提供了两个测试用例，你可以用这两个用例验证你的函数是否能正常运行。写好该函数后，点击“测试答案”按钮测试你的代码。",
              "instructor_notes": ""
            },
            {
              "id": 533995,
              "key": "586bfa7f-f249-4c94-bbf0-39285d8ac8ea",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "586bfa7f-f249-4c94-bbf0-39285d8ac8ea",
                "completed_at": "2018-06-12T08:18:00.947Z",
                "last_viewed_at": "2019-02-23T09:24:42.177Z",
                "unstructured": "{\"pop_density.py\":\"# write your function here\\ndef population_density(population, land_area):\\n    return population/land_area\\n\\n\\n\\n# test cases for your function\\ntest1 = population_density(10, 1)\\nexpected_result1 = 10\\nprint(\\\"expected result: {}, actual result: {}\\\".format(expected_result1, test1))\\n\\ntest2 = population_density(864816, 121.4)\\nexpected_result2 = 7123.6902801\\nprint(\\\"expected result: {}, actual result: {}\\\".format(expected_result2, test2))\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6070447897182208",
                "initial_code_files": [
                  {
                    "text": "# write your function here\n\n\n\n\n# test cases for your function\ntest1 = population_density(10, 1)\nexpected_result1 = 10\nprint(\"expected result: {}, actual result: {}\".format(expected_result1, test1))\n\ntest2 = population_density(864816, 121.4)\nexpected_result2 = 7123.6902801\nprint(\"expected result: {}, actual result: {}\".format(expected_result2, test2))",
                    "name": "pop_density.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 533997,
              "key": "4d6fb0e6-90ab-4da6-a38f-9405e2386a6f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 练习：`readable_timedelta`\n\n写一个叫做 `readable_timedelta` 的函数，该函数有一个参数：整数 `days`，并返回一个表示由多少周多少天组成的字符串。例如 `readable_timedelta(10)` 应返回“1 week(s) and 3 day(s).”。",
              "instructor_notes": ""
            },
            {
              "id": 533998,
              "key": "f8b35dee-8b52-4288-84c1-a60804871be8",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "f8b35dee-8b52-4288-84c1-a60804871be8",
                "completed_at": "2018-06-12T08:21:22.141Z",
                "last_viewed_at": "2019-02-23T09:29:05.426Z",
                "unstructured": "{\"student.py\":\"# write your function here\\ndef readable_timedelta(days):\\n    return str(days//7) + \\\" week(s) and \\\" + str(days%7) + \\\" day(s).\\\" \\n\\n# test your function\\nprint(readable_timedelta(10))\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5358155756863488",
                "initial_code_files": [
                  {
                    "text": "# write your function here\n\n\n# test your function\nprint(readable_timedelta(10))",
                    "name": "student.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 534081,
          "key": "06583dc4-befc-42dc-adad-876e43d3c8ba",
          "title": "解决方案：定义函数",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "06583dc4-befc-42dc-adad-876e43d3c8ba",
            "completed_at": "2018-06-12T08:52:52.507Z",
            "last_viewed_at": "2019-02-23T09:31:37.994Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534003,
              "key": "21a01fdb-7211-45cf-9904-97b23116bc32",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 练习解决方案：人口密度函数\n```python\ndef population_density(population, land_area):\n    return population/land_area\n```\n\n我的函数主体部分只有一行代码，因为我个人喜欢让代码很简练，只要不影响代码的含义就行。你也可以将计算部分与返回语句分开，各占一行。",
              "instructor_notes": ""
            },
            {
              "id": 534004,
              "key": "a1eaaddb-f212-478e-a3e6-d56cd45b7d22",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 练习解决方案：`readable_timedelta`\n\n```python\ndef readable_timedelta(days):\n    # use integer division to get the number of weeks\n    weeks = days // 7\n    # use % to get the number of days that remain\n    remainder = days % 7\n    return \"{} week(s) and {} day(s).\".format(weeks, remainder)\n```\n\n恭喜你写出了首个函数！你很快将看到并编写更多的函数。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534092,
          "key": "98b7dee3-4ce8-4d6b-8950-55d23a3e3241",
          "title": "变量作用域",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "98b7dee3-4ce8-4d6b-8950-55d23a3e3241",
            "completed_at": "2018-06-12T08:58:15.454Z",
            "last_viewed_at": "2019-02-23T09:32:00.076Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 569361,
              "key": "15fb307c-b321-4abc-bc14-0b62eacb18cf",
              "title": "L4 04 Escopo de variável V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "rYubQlAM-gw",
                "china_cdn_id": "rYubQlAM-gw.mp4"
              }
            },
            {
              "id": 534006,
              "key": "cecbee50-57a9-4810-976d-49b65bfff3de",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 变量作用域\n__变量作用域__是指可以在程序的哪个部分引用或使用某个变量。\n\n在函数中使用变量时，务必要考虑作用域。如果变量是在函数内创建的，则只能在该函数内使用该变量。你无法从该函数外面访问该变量。\n```python\n# This will result in an error\ndef some_function():\n    word = \"hello\"\n \nprint(word)\n```\n这意味着你可以为在不同函数内使用的不同变量使用相同的名称。\n```python\n# This works fine\ndef some_function():\n    word = \"hello\"\n \ndef another_function():\n    word = \"goodbye\"\n```\n像这样在函数之外定义的变量依然可以在函数内访问。\n```python\n# This works fine\nword = \"hello\"\n\ndef some_function():\n    print(word)\n\nprint(word)\n```\n注意，我们可以在此函数内以及函数外输出 `word`。作用域对理解信息在用 Python 和任何编程语言编写的程序中的传递方式来说很关键。\n",
              "instructor_notes": ""
            },
            {
              "id": 534007,
              "key": "4ab356fc-45e4-4d2d-9708-5a257cbc1193",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 关于变量作用域的更多信息\n\n在编程时，你经常会发现相似的想法不断出现。你将使用变量进行计数、迭代和累积要返回的值。为了编写容易读懂的代码，你会发现你需要对相似的想法使用相似的名称。一旦你将多段代码放到一起（例如，一个脚本中有多个函数或函数调用），你可能需要为两个不同的概念使用相同的名称。\n\n幸运的是，你不需要不断想出新的名称。可以为对象重复使用相同的名称，只要它们位于不同的作用域即可。\n\n良好实践：建议将变量定义在所需的最小作用域内。虽然函数_可以_引用在更大的作用域内定义的变量，但是通常不建议这么做，因为如果程序有很多变量，你可能不知道你定义了什么变量。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534062,
          "key": "6f936f02-4ba7-46d7-9fac-5a5c5ea8de73",
          "title": "变量作用域",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6f936f02-4ba7-46d7-9fac-5a5c5ea8de73",
            "completed_at": "2018-06-12T09:09:27.145Z",
            "last_viewed_at": "2019-02-23T09:33:53.554Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 533996,
              "key": "98d65711-9d38-410b-8c91-684077a7fe4b",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "98d65711-9d38-410b-8c91-684077a7fe4b",
                "completed_at": "2018-06-12T09:09:53.651Z",
                "last_viewed_at": "2019-02-23T09:32:33.125Z",
                "unstructured": "{\"selected_id\":\"a1514481246513\",\"is_correct\":true}"
              },
              "question": {
                "prompt": "通读下面的代码段：\n\n```python\negg_count = 0\n\ndef buy_eggs():\n    egg_count += 12 # purchase a dozen eggs\n\nbuy_eggs()\n```\n\n运行这段代码后的结果是什么？如果不确定，在自己的计算机上运行一下！",
                "answers": [
                  {
                    "id": "a1514481237657",
                    "text": "`egg_count` 等于 0",
                    "is_correct": false
                  },
                  {
                    "id": "a1514481246002",
                    "text": "`egg_count` 等于 12",
                    "is_correct": false
                  },
                  {
                    "id": "a1514481246513",
                    "text": "发生错误",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 534089,
          "key": "92cc15be-1b0d-4266-9b26-4cec6aa91f93",
          "title": "解决方案：变量作用域",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "92cc15be-1b0d-4266-9b26-4cec6aa91f93",
            "completed_at": "2018-06-12T09:11:50.358Z",
            "last_viewed_at": "2019-02-23T09:34:57.816Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534008,
              "key": "3591a14d-fe3c-467e-8310-c0dd5781fa4d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：变量作用域\n更好的编写方式为：\n```python\negg_count = 0\n\ndef buy_eggs(count):\n    return count + 12  # purchase a dozen eggs\n\negg_count = buy_eggs(egg_count)\n```\n将这段代码与原始代码段进行比较：\n```python\negg_count = 0\n\ndef buy_eggs():\n    egg_count += 12 # purchase a dozen eggs\n\nbuy_eggs()\n```\n下面的代码段导致 `UnboundLocalError`。\n\n在上个视频中，你发现在函数内，我们可以成功地输出外部变量的值。因为我们只是访问该变量的值。当我们尝试将此变量的值__更改__或__重新赋值为__另一个值时，我们将遇到错误。Python 不允许函数修改不在函数作用域内的变量。\n\n但是上面的原则仅适用于整数和字符串，<mark>列表、字典、集合、类中可以在子程序（子函数）中通过修改局部变量达到修改全局变量的目的</mark>。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534101,
          "key": "a9b3f8b5-16e2-4ca8-a11a-ee3722922eb4",
          "title": "文档",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a9b3f8b5-16e2-4ca8-a11a-ee3722922eb4",
            "completed_at": "2018-06-12T09:15:38.368Z",
            "last_viewed_at": "2019-02-23T09:35:57.138Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534009,
              "key": "5e1b616e-87f3-4e12-82a9-06273a69ceea",
              "title": "L4 06 文档 V3 (1)",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "_Vl9NJkA6JQ",
                "china_cdn_id": "_Vl9NJkA6JQ.mp4"
              }
            },
            {
              "id": 534010,
              "key": "5b503871-a29b-4ff3-861e-d04a78c55830",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 文档\n文档使代码更容易理解和使用。函数尤其容易理解，因为它们通常使用文档字符串，简称 docstrings。文档字符串是一种注释，用于解释函数的作用以及使用方式。下面是一个包含文档字符串的人口密度函数。\n```python\ndef population_density(population, land_area):\n    \"\"\"Calculate the population density of an area. \"\"\"\n    return population / land_area\n```\n\n\n文档字符串用三个引号引起来，第一行简要解释了函数的作用。如果你觉得信息已经足够了，可以在文档字符串中只提供这么多的信息；一行文档字符串完全可接受，如上述示例所示。\n```python\ndef population_density(population, land_area):\n    \"\"\"Calculate the population density of an area.\n\n    INPUT:\n    population: int. The population of that area\n    land_area: int or float. This function is unit-agnostic, if you pass in values in terms\n    of square km or square miles the function will return a density in those units.\n\n    OUTPUT: \n    population_density: population / land_area. The population density of a particular area.\n    \"\"\"\n    return population / land_area\n```\n如果你觉得需要更长的句子来解释函数，可以在一行摘要后面添加更多信息。在上述示例中，可以看出我们对函数的参数进行了解释，描述了每个参数的作用和类型。我们经常还会对函数输出进行说明。\n\n文档字符串的每个部分都是可选的。但是，提供文档字符串是一个良好的编程习惯。你可以在[此处](https://www.python.org/dev/peps/pep-0257)详细了解文档字符串惯例。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534096,
          "key": "f4275609-4f8e-4096-a5cb-4cffd660153c",
          "title": "练习：文档",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "f4275609-4f8e-4096-a5cb-4cffd660153c",
            "completed_at": "2018-06-12T09:17:52.579Z",
            "last_viewed_at": "2019-02-23T09:39:02.021Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534012,
              "key": "01cb8261-d4b9-4c64-8c5d-0d483ea17217",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：编写文档字符串\n为你之前定义的 `readable_timedelta` 函数写一个文档字符串！",
              "instructor_notes": ""
            },
            {
              "id": 534013,
              "key": "707d1857-24f0-4bdd-829c-11efe49a7aec",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "707d1857-24f0-4bdd-829c-11efe49a7aec",
                "completed_at": "2018-06-12T09:19:13.200Z",
                "last_viewed_at": "2019-02-23T09:36:27.657Z",
                "unstructured": "{\"docstring.py\":\"def readable_timedelta(days):\\n    # insert your docstring here\\n    '''transfer days into weeks \\n    '''\\n\\n    weeks = days // 7\\n    remainder = days % 7\\n    return \\\"{} week(s) and {} day(s)\\\".format(weeks, remainder)\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5386808574214144",
                "initial_code_files": [
                  {
                    "text": "def readable_timedelta(days):\n    # insert your docstring here\n\n    weeks = days // 7\n    remainder = days % 7\n    return \"{} week(s) and {} day(s)\".format(weeks, remainder)",
                    "name": "docstring.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 534108,
          "key": "31623316-02d8-48b6-8969-9d337d04807d",
          "title": "解决方案：文档",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "31623316-02d8-48b6-8969-9d337d04807d",
            "completed_at": "2018-06-12T09:19:21.281Z",
            "last_viewed_at": "2019-02-23T09:38:43.792Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534014,
              "key": "13567769-2dc0-4ca6-b864-8e2f964c0b28",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 练习解决方案：`readable_timedelta`\n下面是文档字符串的一种编写方式！\n\n```python\ndef readable_timedelta(days):\n    \"\"\"Print the number of weeks and days in a number of days.\"\"\"\n    weeks = days // 7\n    remainder = days % 7\n    return \"{} week(s) and {} day(s)\".format(weeks, remainder)\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534107,
          "key": "258ce5fc-22bc-423c-b321-e0193bd98ace",
          "title": "Lambda 表达式",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "258ce5fc-22bc-423c-b321-e0193bd98ace",
            "completed_at": "2018-06-12T09:19:27.850Z",
            "last_viewed_at": "2019-02-23T09:44:55.914Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534015,
              "key": "e63f9117-ab77-4e8a-bb49-9fe569731d2f",
              "title": "L4 08 Lambda 表达式 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "vfvxIUPFv2Q",
                "china_cdn_id": "vfvxIUPFv2Q.mp4"
              }
            },
            {
              "id": 534016,
              "key": "81f6b3a4-ac68-46f3-9f54-ac620f1ac8a4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Lambda 表达式\n你可以使用 Lambda 表达式创建匿名函数，即没有名称的函数。lambda 表达式非常适合快速创建在代码中以后不会用到的函数。尤其对高阶函数或将其他函数作为参数的函数来说，非常实用。\n\n我们可以使用 lambda 表达式将以下函数\n```python\ndef multiply(x, y):\n    return x * y\n```\n简写为：\n```python\ndouble = lambda x, y: x * y\n```\n### Lambda 函数的组成部分\n1. 关键字 `lambda` 表示这是一个 lambda 表达式。\n2. `lambda` 之后是该匿名函数的一个或多个参数（用英文逗号分隔），然后是一个英文冒号 `:`。和函数相似，lambda 表达式中的参数名称是随意的。\n3. 最后一部分是被评估并在该函数中返回的表达式，和你可能会在函数中看到的 return 语句很像。\n\n鉴于这种结构，lambda 表达式不太适合复杂的函数，但是非常适合简短的函数。",
              "instructor_notes": ""
            },
            {
              "id": 842297,
              "key": "349d64fa-600d-448e-8b24-103fb4e85cac",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "注释：视频里 lamba 应该是 lambda。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534109,
          "key": "9330654f-fbd0-4c90-bb30-cc0cb3b0a078",
          "title": "练习：Lambda 表达式",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "9330654f-fbd0-4c90-bb30-cc0cb3b0a078",
            "completed_at": "2018-06-12T09:21:52.646Z",
            "last_viewed_at": "2019-02-23T10:05:00.749Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534017,
              "key": "068ad8ec-4c49-4f3b-ae1e-9736c2c4292e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：Lambda 与 Map\n`map()` 是一个高阶内置函数，接受函数和可迭代对象作为输入，并返回一个将该函数应用到可迭代对象的每个元素的迭代器。下面的代码使用 `map()` 计算 `numbers` 中每个列表的均值，并创建列表 `averages`。测试运行这段代码，看看结果如何。\n\n通过将 `mean` 函数替换为在 `map()` 的调用中定义的 lambda 表达式，重写这段代码，使代码更简练。",
              "instructor_notes": ""
            },
            {
              "id": 534018,
              "key": "b17d66b9-a2c8-480e-abd6-f9de8988754f",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "b17d66b9-a2c8-480e-abd6-f9de8988754f",
                "completed_at": "2018-06-12T09:25:22.226Z",
                "last_viewed_at": "2019-02-23T10:03:40.031Z",
                "unstructured": "{\"lambda_map.py\":\"numbers = [\\n              [34, 63, 88, 71, 29],\\n              [90, 78, 51, 27, 45],\\n              [63, 37, 85, 46, 22],\\n              [51, 22, 34, 11, 18]\\n           ]\\n\\ndef mean(num_list):\\n    return sum(num_list) / len(num_list)\\n\\naverages = list(map(lambda x:sum(x)/len(x), numbers))\\nprint(averages)\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5961021085319168",
                "initial_code_files": [
                  {
                    "text": "numbers = [\n              [34, 63, 88, 71, 29],\n              [90, 78, 51, 27, 45],\n              [63, 37, 85, 46, 22],\n              [51, 22, 34, 11, 18]\n           ]\n\ndef mean(num_list):\n    return sum(num_list) / len(num_list)\n\naverages = list(map(mean, numbers))\nprint(averages)",
                    "name": "lambda_map.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 534019,
              "key": "f0ff76d5-29cb-49b0-80dd-0ccddb928ab1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：Lambda 与 Filter\n`filter()` 是一个高阶内置函数，接受函数和可迭代对象作为输入，并返回一个由可迭代对象中的特定元素（该函数针对该元素会返回 True）组成的迭代器。下面的代码使用 `filter()` 从 `cities` 中获取长度少于 10 个字符的名称以创建列表 `short_cities`。测试运行这段代码，看看结果如何。\n\n通过将 `is_short` 函数替换为在 `filter()` 的调用中定义的 lambda 表达式，重写这段代码，使代码更简练。",
              "instructor_notes": ""
            },
            {
              "id": 534020,
              "key": "f68c8576-2d45-4bf3-a779-265f7522c74e",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "f68c8576-2d45-4bf3-a779-265f7522c74e",
                "completed_at": "2018-06-12T09:52:06.769Z",
                "last_viewed_at": "2019-02-23T10:06:21.273Z",
                "unstructured": "{\"lambda_filter.py\":\"cities = [\\\"New York City\\\", \\\"Los Angeles\\\", \\\"Chicago\\\", \\\"Mountain View\\\", \\\"Denver\\\", \\\"Boston\\\"]\\n\\n\\nshort_cities = list(filter(lambda x:len(x)<10, cities))\\nprint(short_cities)\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5238863929409536",
                "initial_code_files": [
                  {
                    "text": "cities = [\"New York City\", \"Los Angeles\", \"Chicago\", \"Mountain View\", \"Denver\", \"Boston\"]\n\ndef is_short(name):\n    return len(name) < 10\n\nshort_cities = list(filter(is_short, cities))\nprint(short_cities)",
                    "name": "lambda_filter.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 534110,
          "key": "7ef6a019-e4a7-4cb3-8938-440751a47960",
          "title": "解决方案：Lambda 表达式",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7ef6a019-e4a7-4cb3-8938-440751a47960",
            "completed_at": "2018-06-12T09:35:04.018Z",
            "last_viewed_at": "2019-02-23T10:08:46.431Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534021,
              "key": "a0abdb4a-28bc-467e-8b4a-f596aef3dbf8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：Lambda 与 Map\n```python\nnumbers = [\n              [34, 63, 88, 71, 29],\n              [90, 78, 51, 27, 45],\n              [63, 37, 85, 46, 22],\n              [51, 22, 34, 11, 18]\n           ]\n\naverages = list(map(lambda x: sum(x) / len(x), numbers))\nprint(averages)\n```\n### 输出：\n```txt\n[57.0, 58.2, 50.6, 27.2]\n```",
              "instructor_notes": ""
            },
            {
              "id": 534022,
              "key": "9bba4bd0-afa6-49ce-a28f-ad9946807acb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：Lambda 与 Filter\n```python\ncities = [\"New York City\", \"Los Angeles\", \"Chicago\", \"Mountain View\", \"Denver\", \"Boston\"]\n\nshort_cities = list(filter(lambda x: len(x) < 10, cities))\nprint(short_cities)\n```\n### 输出：\n```txt\n['Chicago', 'Denver', 'Boston']\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534115,
          "key": "50247542-7933-4afe-9130-ff1dff429b03",
          "title": "【选修】迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "50247542-7933-4afe-9130-ff1dff429b03",
            "completed_at": "2018-06-12T09:58:05.529Z",
            "last_viewed_at": "2019-03-03T07:13:46.981Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534023,
              "key": "017906ac-48a8-48c1-88af-32c4698b831d",
              "title": "L4 10 迭代器和生成器 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "tYH8X4Zeh-0",
                "china_cdn_id": "tYH8X4Zeh-0.mp4"
              }
            },
            {
              "id": 534028,
              "key": "3487d6fb-ec0d-4fdf-ab14-66b78479dc20",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 迭代器和生成器\n__迭代器__是每次可以返回一个对象元素的对象，例如返回一个列表。我们到目前为止使用的很多内置函数（例如 enumerate）都会返回一个迭代器。\n\n__迭代器__是一种表示数据流的对象。这与列表不同，列表是可迭代对象，但不是迭代器，因为它不是数据流。\n\n__生成器__是使用函数创建迭代器的简单方式。也可以使用__类__定义迭代器，更多详情请参阅[此处](https://docs.python.org/3/tutorial/classes.html#iterators)。\n\n下面是一个叫做 `my_range` 的生成器函数，它会生成一个从 0 到 (x - 1) 的数字流。\n\n```python\ndef my_range(x):\n    i = 0\n    while i < x:\n        yield i\n        i += 1\n```\n注意，该函数使用了 yield 而不是关键字 return。这样使函数能够一次返回一个值，并且每次被调用时都从停下的位置继续。关键字 yield 是将生成器与普通函数区分开来的依据。\n\n注意，因为这段代码会返回一个迭代器，因此我们可以将其转换为列表或用 for 循环遍历它，以查看其内容。例如，下面的代码：\n```python\nfor x in my_range(5):\n    print(x)\n```\n输出：\n```txt\n0\n1\n2\n3\n4\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534120,
          "key": "8f8f635f-3a64-4430-9f5a-1b9cae806e6d",
          "title": "【选修】练习：迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "8f8f635f-3a64-4430-9f5a-1b9cae806e6d",
            "completed_at": "2018-06-12T10:02:01.119Z",
            "last_viewed_at": "2019-02-23T11:06:23.606Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534029,
              "key": "951cd3c5-a374-41fb-822a-65d7b74e2868",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：实现 `my_enumerate`\n请自己写一个效果和内置函数 `enumerate` 一样的生成器函数。\n\n如下所示地调用该函数：\n```python\nlessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))\n```\n应该会输出：\n```txt\nLesson 1: Why Python Programming\nLesson 2: Data Types and Operators\nLesson 3: Control Flow\nLesson 4: Functions\nLesson 5: Scripting\n```",
              "instructor_notes": ""
            },
            {
              "id": 534030,
              "key": "cf6d568a-79f0-44dc-b136-8b05b7484805",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "cf6d568a-79f0-44dc-b136-8b05b7484805",
                "completed_at": "2018-06-13T00:36:25.933Z",
                "last_viewed_at": "2019-02-23T10:54:19.359Z",
                "unstructured": "{\"my_enumerate.py\":\"lessons = [\\\"Why Python Programming\\\", \\\"Data Types and Operators\\\", \\\"Control Flow\\\", \\\"Functions\\\", \\\"Scripting\\\"]\\n\\ndef my_enumerate(iterable, start=0):\\n    # Implement your generator function here\\n    count = start\\n    for element in iterable:\\n        yield count, element\\n        count+=1\\n\\n\\nfor i, lesson in my_enumerate(lessons, 1):\\n    print(\\\"Lesson {}: {}\\\".format(i, lesson))\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5163475710640128",
                "initial_code_files": [
                  {
                    "text": "lessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\ndef my_enumerate(iterable, start=0):\n    # Implement your generator function here\n\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))",
                    "name": "my_enumerate.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 534031,
              "key": "82478a92-8a6e-49a2-9c7b-141244ba910f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 为何要使用生成器？\n你可能会疑问，为何要使用生成器，而不使用列表。下面这段摘自 [stack overflow 页面](https://softwareengineering.stackexchange.com/questions/290231/when-should-i-use-a-generator-and-when-a-list-in-python/290235) 的内容回答了这个问题：\n\n>生成器是构建迭代器的 “懒惰” 方式。当内存不够存储完整实现的列表时，或者计算每个列表元素的代价很高，你希望尽量推迟计算时，就可以使用生成器。但是这些元素只能遍历一次。\n\n另一种详细的解释如下（详细说明参见 [该 stack overflow 页面](https://softwareengineering.stackexchange.com/questions/273551/should-i-prefer-python-generators-to-lists)。）\n\n> 由于使用生成器是一次处理一个数据，在内存和存储的需求上会比使用 list 方式直接全部生成再存储节省很多资源。\n\n> 由此区别，在处理大量数据时，经常使用生成器初步处理数据后，再进行长期存储，而不是使用 list。因为无论使用生成器还是 list，都是使用过就要丢弃的临时数据。既然功能和结果一样，那就不如用生成器。\n\n> 但是生成器也有自己的局限，它产生的数据不能回溯，不像 list 可以任意选择。\n",
              "instructor_notes": ""
            },
            {
              "id": 534032,
              "key": "3180c2d9-1643-48bf-903b-5b3b26ae3c67",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：Chunker\n如果可迭代对象太大，无法完整地存储在内存中（例如处理大型文件时），每次能够使用一部分很有用。\n\n实现一个生成器函数 `chunker`，接受一个可迭代对象并每次生成指定大小的部分数据。\n\n如下所示地调用该函数：\n```python\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))\n```\n应该会输出：\n```txt\n[0, 1, 2, 3]\n[4, 5, 6, 7]\n[8, 9, 10, 11]\n[12, 13, 14, 15]\n[16, 17, 18, 19]\n[20, 21, 22, 23]\n[24]\n```",
              "instructor_notes": ""
            },
            {
              "id": 534038,
              "key": "fcf5292d-f95b-40fa-a76e-b5beff5dbb7d",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "fcf5292d-f95b-40fa-a76e-b5beff5dbb7d",
                "completed_at": "2018-06-13T00:49:01.225Z",
                "last_viewed_at": "2019-02-23T11:05:38.557Z",
                "unstructured": "{\"chunker.py\":\"def chunker(iterable, size):\\n    # Implement function here\\n    for i in range(0, len(iterable), size):\\n        yield iterable[i:i+size]\\n\\n\\nfor chunk in chunker(range(25), 4):\\n    print(list(chunk))\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6466613495332864",
                "initial_code_files": [
                  {
                    "text": "def chunker(iterable, size):\n    # Implement function here\n\n\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))",
                    "name": "chunker.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 534119,
          "key": "7da0a9fa-5c9b-4e81-a043-0fabd59ba8f0",
          "title": "【选修】解决方案：迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7da0a9fa-5c9b-4e81-a043-0fabd59ba8f0",
            "completed_at": "2018-06-13T00:38:31.421Z",
            "last_viewed_at": "2019-02-23T11:08:04.583Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534039,
              "key": "928aa1fb-97d8-4e61-8b0f-e47e00fd11a1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：实现 `my_enumerate`\n```python\nlessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\ndef my_enumerate(iterable, start=0):\n    count = start\n    for element in iterable:\n        yield count, element\n        count += 1\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))\n```\n### 输出：\n```txt\nLesson 1: Why Python Programming\nLesson 2: Data Types and Operators\nLesson 3: Control Flow\nLesson 4: Functions\nLesson 5: Scripting\n```",
              "instructor_notes": ""
            },
            {
              "id": 534040,
              "key": "d3a112f8-ec87-413e-8a29-216f93f826a5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：Chunker\n以下是一种实现方式。你可以在此 [Stack Overflow 页面](https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks)上找到该实现。\n```python\ndef chunker(iterable, size):\n    \"\"\"Yield successive chunks from iterable of length size.\"\"\"\n    for i in range(0, len(iterable), size):\n        yield iterable[i:i + size]\n\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))\n```\n### 输出：\n```txt\n[0, 1, 2, 3]\n[4, 5, 6, 7]\n[8, 9, 10, 11]\n[12, 13, 14, 15]\n[16, 17, 18, 19]\n[20, 21, 22, 23]\n[24]\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534127,
          "key": "851a31fc-8e66-4737-8262-1e402e493fec",
          "title": "总结",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "851a31fc-8e66-4737-8262-1e402e493fec",
            "completed_at": "2018-06-13T00:59:00.049Z",
            "last_viewed_at": "2019-05-12T14:16:10.613Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534050,
              "key": "b2993877-1af3-461c-98e0-084632420cbc",
              "title": "L4 12 总结 V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "QRnLr7pwHyk",
                "china_cdn_id": "QRnLr7pwHyk.mp4"
              }
            }
          ]
        }
      ]
    }
  }
}